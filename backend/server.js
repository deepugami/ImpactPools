import express from 'express'
import cors from 'cors'
import helmet from 'helmet'
import morgan from 'morgan'
import dotenv from 'dotenv'
import fs from 'fs'
import path from 'path'
// NEW: Import NFT routes
import nftRoutes from './routes/nft.js'
// NEW: Import withdrawal routes
import withdrawalRoutes from './routes/withdrawal.js'

// Load environment variables
dotenv.config()

// Create Express application
const app = express()
const PORT = process.env.PORT || 4000

/**
 * Data persistence setup
 * Use JSON file for simple persistence to prevent data loss on restart
 */
const DATA_FILE = path.join(process.cwd(), 'pools-data.json')

/**
 * Load pools from JSON file
 */
const loadPoolsFromFile = () => {
  try {
    if (fs.existsSync(DATA_FILE)) {
      const data = fs.readFileSync(DATA_FILE, 'utf8')
      const parsed = JSON.parse(data)
      return parsed
    }
  } catch (error) {
    console.warn('⚠️ Failed to load pools from file:', error.message)
  }
  return []
}

/**
 * Save pools to JSON file
 */
const savePoolsToFile = (poolsData) => {
  try {
    fs.writeFileSync(DATA_FILE, JSON.stringify(poolsData, null, 2))
  } catch (error) {
    console.error('❌ Failed to save pools to file:', error.message)
  }
}

/**
 * In-memory storage for pools with file persistence
 * Loads existing data on startup, saves on changes
 */
let pools = loadPoolsFromFile()

/**
 * Yield Generation Service
 * Calculates and applies yield to all active pools every 10 minutes
 */
class YieldService {
  constructor() {
    this.isRunning = false;
    this.interval = null;
    this.YIELD_UPDATE_INTERVAL = 30 * 1000; // 30 seconds for real-time yield generation
  }

  start() {
    if (this.isRunning) {
      return;
    }

    this.isRunning = true;

    // Run immediately on start
    this.generateYieldForAllPools();

    // Set up 30-second interval for real-time yield generation
    this.interval = setInterval(() => {
      this.generateYieldForAllPools();
    }, this.YIELD_UPDATE_INTERVAL);
  }

  stop() {
    if (this.interval) {
      clearInterval(this.interval);
      this.interval = null;
    }
    this.isRunning = false;
  }

  generateYieldForAllPools() {
    try {
      if (!pools || pools.length === 0) {
        return;
      }

      let totalNewYield = 0;
      let totalNewDonations = 0;
      let updatedPoolsCount = 0;

      pools.forEach((pool, index) => {
        const yieldData = this.calculatePoolYield(pool);
        
        if (yieldData.newYield > 0) {
          updatedPoolsCount++;
          totalNewYield += yieldData.newYield;
          totalNewDonations += yieldData.donationAmount;
          
          // Update the pool in the array
          pools[index] = yieldData.updatedPool;
        }
      });

      // Save updated pools to file
      if (updatedPoolsCount > 0) {
        savePoolsToFile(pools);
      }

    } catch (error) {
      console.error('❌ [YIELD] Error generating yield:', error);
    }
  }

  calculatePoolYield(pool) {
    try {
      // Only generate yield if pool has deposits
      if (!pool.totalDeposited || pool.totalDeposited <= 0) {
        return { updatedPool: pool, newYield: 0, donationAmount: 0 };
      }

      // Calculate yield based on APY and time elapsed (30 seconds for real-time generation)
      const annualAPY = (pool.currentAPY || 4.2) / 100; // Convert percentage to decimal
      const secondsElapsed = 30; // 30-second intervals for real-time yield
      const secondsPerYear = 365 * 24 * 60 * 60; // Seconds in a year
      
      // Calculate yield for this 30-second period
      const periodMultiplier = secondsElapsed / secondsPerYear;
      const yieldForPeriod = pool.totalDeposited * annualAPY * periodMultiplier;

      // Calculate donations based on donation percentage
      const donationPercentage = pool.donationPercentage || 0;
      const donationAmount = yieldForPeriod * (donationPercentage / 100);

      // Update pool with accumulated yield and donations
      const updatedPool = {
        ...pool,
        totalYieldGenerated: (pool.totalYieldGenerated || 0) + yieldForPeriod,
        totalDonated: (pool.totalDonated || 0) + donationAmount,
        lastYieldUpdate: new Date().toISOString(),
        
        // Add yield distribution transaction record
        transactions: [
          ...(pool.transactions || []),
          {
            id: `yield_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
            type: 'yield_distribution',
            amount: yieldForPeriod,
            donationAmount: donationAmount,
            asset: 'XLM',
            timestamp: new Date().toISOString(),
            periodAPY: annualAPY * 100,
            isAutoGenerated: true
          }
        ]
      };

      return {
        updatedPool,
        newYield: yieldForPeriod,
        donationAmount: donationAmount
      };

    } catch (error) {
      console.error(`❌ [YIELD] Error calculating yield for pool ${pool.id}:`, error);
      return { updatedPool: pool, newYield: 0, donationAmount: 0 };
    }
  }

  getStatus() {
    return {
      isRunning: this.isRunning,
      intervalSeconds: this.YIELD_UPDATE_INTERVAL / 1000,
      intervalMinutes: this.YIELD_UPDATE_INTERVAL / (60 * 1000),
      nextUpdate: this.isRunning ? new Date(Date.now() + this.YIELD_UPDATE_INTERVAL).toISOString() : null
    };
  }
}

// Initialize yield service
const yieldService = new YieldService();

// Middleware setup
app.use(helmet()) // Security headers
app.use(cors({
  origin: function (origin, callback) {
    // Allow requests with no origin (like mobile apps, Postman, etc.)
    if (!origin) return callback(null, true);
    
    // Allow all localhost ports for development
    if (origin.match(/^http:\/\/localhost:\d+$/)) {
      return callback(null, true);
    }
    
    // Allow specific production origins
    const allowedOrigins = [
      'http://localhost:3000',
      'https://your-production-domain.com' // Add your production domain here
    ];
    
    if (allowedOrigins.includes(origin)) {
      return callback(null, true);
    }
    
    return callback(new Error('Not allowed by CORS'));
  },
  credentials: true
})) // Enable CORS for all localhost ports
app.use(morgan('combined')) // Request logging
app.use(express.json({ limit: '10mb' })) // Parse JSON bodies
app.use(express.urlencoded({ extended: true })) // Parse URL-encoded bodies

/**
 * Health check endpoint
 * Useful for deployment monitoring and basic server status
 */
app.get('/health', (req, res) => {
  res.status(200).json({
    status: 'OK',
    timestamp: new Date().toISOString(),
    uptime: process.uptime(),
    environment: process.env.NODE_ENV || 'development'
  })
})

/**
 * API Routes
 */

/**
 * GET /api/pools
 * Retrieve all available ImpactPools
 * 
 * Returns: Array of pool objects with all their details
 */
app.get('/api/pools', (req, res) => {
  try {
    // Return all pools sorted by creation date (newest first)
    const sortedPools = pools.sort((a, b) => 
      new Date(b.createdAt) - new Date(a.createdAt)
    )
    
    res.status(200).json(sortedPools)
  } catch (error) {
    console.error('Error fetching pools:', error)
    res.status(500).json({
      error: 'Internal server error',
      message: 'Failed to fetch pools'
    })
  }
})

/**
 * GET /api/pools/:id
 * Retrieve a specific pool by ID
 * 
 * Params:
 *   - id: Pool identifier
 * 
 * Returns: Pool object or 404 if not found
 */
app.get('/api/pools/:id', (req, res) => {
  try {
    const { id } = req.params
    const pool = pools.find(p => p.id === id)
    
    if (!pool) {
      return res.status(404).json({
        error: 'Pool not found',
        message: `No pool found with ID: ${id}`
      })
    }
    
    res.status(200).json(pool)
  } catch (error) {
    console.error('Error fetching pool:', error)
    res.status(500).json({
      error: 'Internal server error',
      message: 'Failed to fetch pool'
    })
  }
})

/**
 * POST /api/pools
 * Create a new ImpactPool
 * 
 * Body: Pool object with all required fields
 * 
 * Returns: Created pool object with generated ID
 */
app.post('/api/pools', (req, res) => {
  try {
    const poolData = req.body
    
    // Basic validation
    if (!poolData.name || !poolData.charity || !poolData.assets || !poolData.creator) {
      return res.status(400).json({
        error: 'Missing required fields',
        message: 'Pool must have name, charity, assets, and creator'
      })
    }
    
    // Validate donation percentage
    if (poolData.donationPercentage < 1 || poolData.donationPercentage > 50) {
      return res.status(400).json({
        error: 'Invalid donation percentage',
        message: 'Donation percentage must be between 1% and 50%'
      })
    }
    
    // Validate assets array
    if (!Array.isArray(poolData.assets) || poolData.assets.length === 0) {
      return res.status(400).json({
        error: 'Invalid assets',
        message: 'Assets must be a non-empty array'
      })
    }
    
    // Add the new pool to our storage
    pools.push(poolData)
    
    // Save to persistent storage
    savePoolsToFile(pools)
    
    res.status(201).json(poolData)
  } catch (error) {
    console.error('Error creating pool:', error)
    res.status(500).json({
      error: 'Internal server error',
      message: 'Failed to create pool'
    })
  }
})

/**
 * PUT /api/pools/:id
 * Update an existing pool (for deposits, withdrawals, etc.)
 * 
 * Params:
 *   - id: Pool identifier
 * Body: Updated pool object
 * 
 * Returns: Updated pool object
 */
app.put('/api/pools/:id', (req, res) => {
  try {
    const { id } = req.params
    const updatedPoolData = req.body
    
    // Find the pool index
    const poolIndex = pools.findIndex(p => p.id === id)
    
    if (poolIndex === -1) {
      return res.status(404).json({
        error: 'Pool not found',
        message: `No pool found with ID: ${id}`
      })
    }
    
    // Update the pool
    pools[poolIndex] = {
      ...pools[poolIndex],
      ...updatedPoolData,
      id: id // Ensure ID doesn't change
    }
    
    // Save to persistent storage
    savePoolsToFile(pools)
    
    res.status(200).json(pools[poolIndex])
  } catch (error) {
    console.error('Error updating pool:', error)
    res.status(500).json({
      error: 'Internal server error',
      message: 'Failed to update pool'
    })
  }
})

/**
 * DELETE /api/pools/:id
 * Delete a pool (creator only in production)
 * 
 * Params:
 *   - id: Pool identifier
 * 
 * Returns: Success message
 */
app.delete('/api/pools/:id', (req, res) => {
  try {
    const { id } = req.params
    
    const poolIndex = pools.findIndex(p => p.id === id)
    
    if (poolIndex === -1) {
      return res.status(404).json({
        error: 'Pool not found',
        message: `No pool found with ID: ${id}`
      })
    }
    
    // Remove the pool
    const deletedPool = pools.splice(poolIndex, 1)[0]
    
    // Save to persistent storage
    savePoolsToFile(pools)
    
    res.status(200).json({
      success: true,
      message: 'Pool deleted successfully',
      deletedPool: deletedPool
    })
  } catch (error) {
    console.error('Error deleting pool:', error)
    res.status(500).json({
      error: 'Internal server error',
      message: 'Failed to delete pool'
    })
  }
})

/**
 * GET /api/stats
 * Get platform-wide statistics
 * 
 * Returns: Aggregated statistics across all pools
 */
app.get('/api/stats', (req, res) => {
  try {
    const stats = {
      totalPools: pools.length,
      totalValueLocked: pools.reduce((sum, pool) => sum + pool.totalDeposited, 0),
      totalDonated: pools.reduce((sum, pool) => sum + pool.totalDonated, 0),
      totalParticipants: pools.reduce((sum, pool) => sum + pool.participants, 0),
      averageAPY: pools.length > 0 
        ? pools.reduce((sum, pool) => sum + pool.currentAPY, 0) / pools.length 
        : 0,
      totalYieldGenerated: pools.reduce((sum, pool) => sum + pool.totalYieldGenerated, 0)
    }
    
    res.status(200).json(stats)
  } catch (error) {
    console.error('Error calculating stats:', error)
    res.status(500).json({
      error: 'Internal server error',
      message: 'Failed to calculate platform statistics'
    })
  }
})

// NFT Impact Certificates Routes
// NEW: Add NFT routes alongside existing functionality
app.use('/api/nft', nftRoutes);
// NEW: Add withdrawal routes alongside existing functionality
app.use('/api/withdrawal', withdrawalRoutes);

/**
 * Error handling middleware
 * Catches any unhandled errors and returns a proper response
 */
app.use((error, req, res, next) => {
  console.error('Unhandled error:', error)
  
  res.status(500).json({
    error: 'Internal server error',
    message: 'Something went wrong on the server'
  })
})

/**
 * 404 handler for undefined routes
 */
app.use('*', (req, res) => {
  res.status(404).json({
    error: 'Route not found',
    message: `The requested route ${req.originalUrl} does not exist`
  })
})

/**
 * GET /api/yield/status
 * Get yield service status
 */
app.get('/api/yield/status', (req, res) => {
  try {
    const status = yieldService.getStatus()
    res.status(200).json(status)
  } catch (error) {
    console.error('Error getting yield service status:', error)
    res.status(500).json({
      error: 'Internal server error',
      message: 'Failed to get yield service status'
    })
  }
})

/**
 * Start the server
 */
app.listen(PORT, () => {
  console.log(`🚀 ImpactPools API server running on port ${PORT}`)
  
  // Start yield generation service
  setTimeout(() => {
    yieldService.start()
  }, 2000) // Start after 2 seconds to ensure server is fully ready
})

// Graceful shutdown handling
process.on('SIGTERM', () => {
  console.log('SIGTERM received, shutting down gracefully')
  process.exit(0)
})

process.on('SIGINT', () => {
  console.log('SIGINT received, shutting down gracefully')
  process.exit(0)
})

export default app 